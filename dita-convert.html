<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DITA Editor</title>
    <!-- Tailwind CSS CDN for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter font from Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- html2pdf.js library for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        /* Custom styles for the rich text editor placeholder */
        [contenteditable="true"]:empty:before {
            content: attr(data-placeholder);
            color: #9ca3af; /* Tailwind's gray-400 */
            pointer-events: none;
            display: block;
        }
        /* Simple icon styling for the toolbar buttons */
        .toolbar-btn {
            font-size: 1.25rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 0.375rem;
            transition: background-color 0.2s;
            line-height: 1;
        }
        .toolbar-btn:hover {
            background-color: #e5e7eb; /* gray-200 */
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col p-4 md:p-8">
    <header class="text-center mb-6">
        <h1 class="text-3xl font-bold text-gray-800">DITA XML Editor</h1>
    </header>

    <!-- AI Prompt Section -->
    <div class="bg-white rounded-lg shadow-md p-6 border border-gray-200 mb-6">
        <h2 class="text-lg font-semibold text-gray-700 mb-4">Generate with AI</h2>
        <div class="flex flex-col md:flex-row gap-4 items-center">
            <textarea id="aiPrompt"
                      class="flex-1 w-full p-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none"
                      rows="3"
                      placeholder="Type a prompt for the AI, e.g., 'Write a short user guide for an espresso machine.'"></textarea>
            <button id="generateBtn"
                    class="bg-[#4CAF50] hover:bg-[#45a049] text-white font-bold py-3 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105 min-w-[120px]">
                Generate
            </button>
        </div>
    </div>

    <main class="flex-1 flex flex-col md:flex-row gap-4 mb-6">
        <!-- Rich Text Editor Section -->
        <div class="flex-1 bg-white rounded-lg shadow-md p-6 border border-gray-200 flex flex-col">
            <h2 class="text-lg font-semibold text-gray-700 mb-4">Rich Text Editor</h2>
            
            <!-- Rich Text Editor Toolbar -->
            <div id="toolbar" class="bg-gray-100 p-2 rounded-t-lg border-b border-gray-300 flex flex-wrap gap-1 mb-2">
                <button class="toolbar-btn" data-command="bold"><b>B</b></button>
                <button class="toolbar-btn" data-command="italic"><i>I</i></button>
                <button class="toolbar-btn" data-command="underline"><u>U</u></button>
                <button class="toolbar-btn" data-command="insertUnorderedList" title="Unordered List">&#x2022; List</button>
                <button class="toolbar-btn" data-command="insertOrderedList" title="Ordered List">1. List</button>
            </div>
            
            <!-- The contenteditable div serves as the rich text editor -->
            <div id="richTextEditor"
                 class="flex-1 w-full p-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 overflow-auto"
                 contenteditable="true"
                 data-placeholder="Start typing or pasting content here.">
            </div>
        </div>

        <!-- DITA XML Viewer Section -->
        <div class="flex-1 bg-gray-900 text-gray-300 rounded-lg shadow-md p-6 border border-gray-700 flex flex-col">
            <h2 class="text-lg font-semibold text-white mb-4">DITA XML Code</h2>
            <!-- The textarea displays the DITA XML code -->
            <textarea id="xmlEditor"
                      class="flex-1 w-full h-full bg-gray-800 text-gray-300 p-4 rounded-lg font-mono text-sm focus:outline-none focus:ring-2 focus:ring-gray-600 resize-none overflow-auto"
                      placeholder="XML code will appear here."></textarea>
        </div>
    </main>

    <!-- Controls Section -->
    <div class="flex flex-col md:flex-row justify-center items-center gap-4">
        <!-- Button to download as PDF -->
        <button id="downloadPdfBtn"
                class="bg-[#4CAF50] hover:bg-[#45a049] text-white font-bold py-3 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105">
            Download PDF
        </button>
        <!-- Button to download as HTML -->
        <button id="downloadHtmlBtn"
                class="bg-[#4CAF50] hover:bg-[#45a049] text-white font-bold py-3 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105">
            Download HTML
        </button>
    </div>

    <script>
        // Get references to the DOM elements
        const richTextEditor = document.getElementById('richTextEditor');
        const xmlEditor = document.getElementById('xmlEditor');
        const aiPrompt = document.getElementById('aiPrompt');
        const generateBtn = document.getElementById('generateBtn');
        const toolbar = document.getElementById('toolbar');
        const downloadPdfBtn = document.getElementById('downloadPdfBtn');
        const downloadHtmlBtn = document.getElementById('downloadHtmlBtn');

        // Flag to prevent infinite loops during two-way binding
        let isUpdating = false;

        /**
         * Converts the HTML content from the rich text editor to DITA XML.
         * This is a simplified conversion for demonstration purposes.
         * A more robust solution would require a full DITA-OT-compliant parser.
         * @param {string} htmlString - The HTML content to convert.
         * @returns {string} The formatted DITA XML string.
         */
        function htmlToDita(htmlString) {
            // If the rich text editor is empty, return an empty string to prevent parsing errors
            if (!htmlString.trim()) {
                return '';
            }

            // Create a temporary element to parse the HTML string
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const body = doc.body;

            // Start with a basic DITA topic structure
            let ditaXml = '<?xml version="1.0" encoding="UTF-8"?>\n' +
                          '<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">\n' +
                          '<topic id="my-topic">\n';

            // Find the first heading (h1, h2, h3) and treat it as the topic title
            const firstHeading = body.querySelector('h1, h2, h3');
            if (firstHeading) {
                ditaXml += `  <title>${firstHeading.innerText}</title>\n`;
                firstHeading.remove(); // Remove it from the body to avoid processing twice
            } else {
                ditaXml += '  <title>New Topic</title>\n';
            }

            // Begin the body element
            ditaXml += '  <body>\n';

            // Process paragraphs and other elements
            const paragraphs = body.querySelectorAll('p, div, ul, ol, h4, h5, h6, strong, em, b, i');
            paragraphs.forEach(p => {
                // Check if the element has a list parent
                const isListItem = p.parentElement && (p.parentElement.tagName === 'UL' || p.parentElement.tagName === 'OL');
                if (isListItem) {
                    // Do not process list items as separate paragraphs
                    return;
                }

                let content = p.innerHTML;

                // Simple replacements for common formatting
                content = content.replace(/<strong>(.*?)<\/strong>/g, '<bdo>$1</bdo>');
                content = content.replace(/<b>(.*?)<\/b>/g, '<bdo>$1</bdo>');
                content = content.replace(/<em>(.*?)<\/em>/g, '<emphasis>$1</emphasis>');
                content = content.replace(/<i>(.*?)<\/i>/g, '<emphasis>$1</emphasis>');
                content = content.replace(/<u>(.*?)<\/u>/g, '<ph style="text-decoration: underline;">$1</ph>');

                // Strip any remaining HTML tags and handle lists
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = p.innerHTML;

                let listXml = '';
                const lists = tempDiv.querySelectorAll('ul, ol');
                if (lists.length > 0) {
                    lists.forEach(list => {
                        const listItems = list.querySelectorAll('li');
                        if (listItems.length > 0) {
                            if (list.tagName === 'UL') {
                                listXml += `    <ul id="ul1">\n`;
                            } else {
                                listXml += `    <ol id="ol1">\n`;
                            }
                            listItems.forEach(item => {
                                listXml += `      <li>${item.textContent}</li>\n`;
                            });
                            if (list.tagName === 'UL') {
                                listXml += `    </ul>\n`;
                            } else {
                                listXml += `    </ol>\n`;
                            }
                        }
                    });
                }
                
                // Add a <p> tag if content is not empty
                const strippedContent = tempDiv.textContent.trim();
                if (strippedContent) {
                    ditaXml += `    <p>${strippedContent}</p>\n`;
                }
                
                // Add list XML if present
                ditaXml += listXml;
            });

            // Close the body and topic elements
            ditaXml += '  </body>\n' +
                       '</topic>';
            return ditaXml;
        }

        /**
         * Converts DITA XML string back to a basic HTML representation.
         * This is a simplified process using DOMParser.
         * @param {string} ditaString - The DITA XML string to convert.
         * @returns {string} The formatted HTML string.
         */
        function ditaToHtml(ditaString) {
            // If the DITA XML editor is empty, return an empty string
            if (!ditaString.trim()) {
                return '';
            }

            // Use DOMParser to safely parse the XML string
            const parser = new DOMParser();
            let doc;
            try {
                doc = parser.parseFromString(ditaString, 'text/xml');
                // Check for parser errors
                const errorNode = doc.querySelector('parsererror');
                if (errorNode) {
                    // Log the error but don't stop the application
                    console.error("XML Parsing Error:", errorNode.textContent);
                    // Return an empty string or a simple error message to the user
                    return `<p class="text-red-500">Error parsing DITA XML. Please check your syntax.</p>`;
                }
            } catch (e) {
                console.error("XML Parsing Error:", e);
                return `<p class="text-red-500">Error parsing DITA XML: ${e.message}</p>`;
            }

            // Get the root topic element
            const topic = doc.querySelector('topic');
            if (!topic) {
                return '<p>No &lt;topic&gt; element found.</p>';
            }

            let htmlContent = '';

            // Convert the title
            const title = topic.querySelector('title');
            if (title) {
                htmlContent += `<h1>${title.innerHTML}</h1>`;
            }

            // Convert the body content
            const body = topic.querySelector('body');
            if (body) {
                body.childNodes.forEach(node => {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        switch (node.tagName) {
                            case 'p':
                                let pContent = node.innerHTML;
                                // Simple DITA-to-HTML formatting
                                pContent = pContent.replace(/<bdo>/g, '<strong>').replace(/<\/bdo>/g, '</strong>');
                                pContent = pContent.replace(/<emphasis>/g, '<em>').replace(/<\/emphasis>/g, '</em>');
                                pContent = pContent.replace(/<ph style="text-decoration: underline;">/g, '<u>').replace(/<\/ph>/g, '</u>');
                                htmlContent += `<p>${pContent}</p>`;
                                break;
                            case 'ul':
                                // Handle unordered lists
                                htmlContent += `<ul>${node.innerHTML}</ul>`;
                                break;
                            case 'ol':
                                // Handle ordered lists
                                htmlContent += `<ol>${node.innerHTML}</ol>`;
                                break;
                            // Add more cases for other DITA elements as needed
                        }
                    }
                });
            }

            return htmlContent;
        }
        
        // --- Gemini AI Integration ---
        generateBtn.addEventListener('click', async () => {
            const userPrompt = aiPrompt.value.trim();
            if (!userPrompt) {
                aiPrompt.placeholder = 'Please enter a prompt before generating content.';
                return;
            }

            // Show loading state
            generateBtn.textContent = 'Generating...';
            generateBtn.disabled = true;
            generateBtn.classList.add('opacity-50', 'cursor-not-allowed');

            try {
                // Make the API call with the correct model ID
                const chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: userPrompt }] });
                const payload = { contents: chatHistory };
                const apiKey = "AIzaSyDdj6VoNhgKHIh3myG_UPzfXseXRLPUldE" 
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;
                
                // Fetch with exponential backoff
                let response;
                let retryDelay = 1000;
                const maxRetries = 5;
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        // Check for a non-error status code before breaking the loop
                        if (response.ok) {
                           break;
                        }
                        // Handle rate limit specifically to retry
                        if (response.status !== 429) {
                            throw new Error(`API Error: ${response.status} ${response.statusText}`);
                        }
                    } catch (error) {
                        // Network error or other non-rate-limit errors
                        if (i === maxRetries - 1) {
                           throw error; // Rethrow on last retry
                        }
                    }
                    if (i < maxRetries - 1) {
                        await new Promise(res => setTimeout(res, retryDelay));
                        retryDelay *= 2;
                    }
                }
                
                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                    const generatedText = result.candidates[0].content.parts[0].text;
                    // Simple text-to-HTML conversion, converting newlines to <br> tags
                    const generatedHtml = `<p>${generatedText.replace(/\n/g, '<br>')}</p>`;
                    
                    isUpdating = true;
                    richTextEditor.innerHTML = generatedHtml;
                    const generatedDita = htmlToDita(generatedHtml);
                    xmlEditor.value = generatedDita;
                    isUpdating = false;

                } else {
                    console.error("API response did not contain content.");
                    richTextEditor.innerHTML = '<p class="text-red-500">Sorry, I couldn\'t generate content. Please try again.</p>';
                    xmlEditor.value = '';
                }

            } catch (error) {
                console.error('Error generating content:', error);
                richTextEditor.innerHTML = '<p class="text-red-500">There was an error connecting to the API. Please try again later.</p>';
                xmlEditor.value = '';
            } finally {
                // Reset loading state
                generateBtn.textContent = 'Generate';
                generateBtn.disabled = false;
                generateBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        });

        // --- Rich Text Editor Toolbar Logic ---
        toolbar.addEventListener('click', (event) => {
            const button = event.target.closest('button');
            if (button) {
                const command = button.dataset.command;
                if (command) {
                    document.execCommand(command, false, null);
                    // Ensure the content is updated after command execution
                    const ditaXml = htmlToDita(richTextEditor.innerHTML);
                    xmlEditor.value = ditaXml;
                }
            }
        });

        // --- Event Listeners for Two-Way Sync ---

        // Listen for changes in the rich text editor to update the XML
        richTextEditor.addEventListener('input', () => {
            if (isUpdating) return;
            isUpdating = true;
            const ditaXml = htmlToDita(richTextEditor.innerHTML);
            xmlEditor.value = ditaXml;
            isUpdating = false;
        });

        // Listen for changes in the XML editor to update the rich text
        xmlEditor.addEventListener('input', () => {
            if (isUpdating) return;
            isUpdating = true;
            const htmlContent = ditaToHtml(xmlEditor.value);
            richTextEditor.innerHTML = htmlContent;
            isUpdating = false;
        });

        // --- Event Listeners for Download Buttons ---

        // Download HTML
        downloadHtmlBtn.addEventListener('click', () => {
            const content = richTextEditor.innerHTML;
            const blob = new Blob([content], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'document.html';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // Download PDF
        downloadPdfBtn.addEventListener('click', () => {
            const element = richTextEditor;
            // Use html2pdf.js to generate and download the PDF
            html2pdf().from(element).set({
                margin: 10,
                filename: 'document.pdf',
                html2canvas: { scale: 2 },
                jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
            }).save();
        });

        // Initial content sync on page load
        // This makes sure both editors start with the same content
        richTextEditor.innerHTML = ditaToHtml(xmlEditor.value);
    </script>
</body>
</html>

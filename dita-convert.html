<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DITA Editor</title>
    <!-- Tailwind CSS CDN for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter font from Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- html2pdf.js library for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        /* Custom styles for the rich text editor placeholder */
        [contenteditable="true"]:empty:before {
            content: attr(data-placeholder);
            color: #9ca3af; /* Tailwind's gray-400 */
            pointer-events: none;
            display: block;
        }
        /* Simple icon styling for the toolbar buttons */
        .toolbar-btn {
            font-size: 1.25rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 0.375rem;
            transition: background-color 0.2s;
            line-height: 1;
            display: inline-flex;
            justify-content: center;
            align-items: center;
        }
        .toolbar-btn:hover {
            background-color: #e5e7eb; /* gray-200 */
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col p-4 md:p-8">
    <header class="text-center mb-6">
        <h1 class="text-3xl font-bold text-gray-800">DITA XML Editor</h1>
    </header>

    <!-- AI Prompt Section -->
    <div class="bg-white rounded-lg shadow-md p-6 border border-gray-200 mb-6">
        <h2 class="text-lg font-semibold text-gray-700 mb-4">Generate with AI</h2>
        <div class="flex flex-col md:flex-row gap-4 items-center">
            <textarea id="aiPrompt"
                      class="flex-1 w-full p-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none"
                      rows="3"
                      placeholder="Type a prompt for the AI, e.g., 'Write a short user guide for an espresso machine.'"></textarea>
            <button id="generateBtn"
                    class="bg-[#4CAF50] hover:bg-[#45a049] text-white font-bold py-3 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105 min-w-[120px]">
                Generate
            </button>
        </div>
    </div>

    <main class="flex-1 flex flex-col md:flex-row gap-4 mb-6">
        <!-- Rich Text Editor Section -->
        <div class="flex-1 bg-white rounded-lg shadow-md p-6 border border-gray-200 flex flex-col">
            <h2 class="text-lg font-semibold text-gray-700 mb-4">Rich Text Editor</h2>
            
            <!-- Rich Text Editor Toolbar -->
            <div id="toolbar" class="bg-gray-100 p-2 rounded-t-lg border-b border-gray-300 flex flex-wrap gap-1 mb-2">
                <button class="toolbar-btn" data-command="bold"><b>B</b></button>
                <button class="toolbar-btn" data-command="italic"><i>I</i></button>
                <button class="toolbar-btn" data-command="underline"><u>U</u></button>
                <button class="toolbar-btn" data-command="insertUnorderedList" title="Unordered List">&#x2022; List</button>
                <button class="toolbar-btn" data-command="insertOrderedList" title="Ordered List">1. List</button>
                <button class="toolbar-btn" data-command="formatBlock" data-value="H1" title="Heading 1">H1</button>
                <button class="toolbar-btn" data-command="formatBlock" data-value="H2" title="Heading 2">H2</button>
                <button class="toolbar-btn" data-command="formatBlock" data-value="H3" title="Heading 3">H3</button>
                <button class="toolbar-btn" data-command="formatBlock" data-value="p" title="Paragraph">P</button>
                <button class="toolbar-btn" data-command="createLink" title="Link">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5.656 5.656a2 2 0 012.828 0l3 3a2 2 0 11-2.828 2.828l-3-3a2 2 0 010-2.828 1 1 0 00-1.414-1.414 4 4 0 000 5.656l3 3a4 4 0 005.656 0 1 1 0 00-1.414-1.414L10 12.586a2 2 0 01-2.828 0z" clip-rule="evenodd" />
                    </svg>
                </button>
                <button class="toolbar-btn" data-command="blockquote" title="Blockquote">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M11 3a1 1 0 100 2h6a1 1 0 100-2h-6zM11 7a1 1 0 100 2h6a1 1 0 100-2h-6zM11 11a1 1 0 100 2h6a1 1 0 100-2h-6zM11 15a1 1 0 100 2h6a1 1 0 100-2h-6z" />
                        <path fill-rule="evenodd" d="M4 3a1 1 0 00-1 1v12a1 1 0 001 1h2a1 1 0 001-1v-5l3 2v-5l-3 2V4a1 1 0 00-1-1H4z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>
            
            <!-- The contenteditable div serves as the rich text editor -->
            <div id="richTextEditor"
                 class="flex-1 w-full p-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 overflow-auto"
                 contenteditable="true"
                 data-placeholder="Start typing or pasting content here.">
            </div>
        </div>

        <!-- DITA XML Viewer Section -->
        <div class="flex-1 bg-gray-900 text-gray-300 rounded-lg shadow-md p-6 border border-gray-700 flex flex-col">
            <h2 class="text-lg font-semibold text-white mb-4">DITA XML Code</h2>
            <!-- The textarea displays the DITA XML code -->
            <textarea id="xmlEditor"
                      class="flex-1 w-full h-full bg-gray-800 text-gray-300 p-4 rounded-lg font-mono text-sm focus:outline-none focus:ring-2 focus:ring-gray-600 resize-none overflow-auto"
                      placeholder="XML code will appear here."></textarea>
        </div>
    </main>

    <!-- Controls Section -->
    <div class="flex flex-col md:flex-row justify-center items-center gap-4">
        <!-- Button to download as PDF -->
        <button id="downloadPdfBtn"
                class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105">
            Download PDF
        </button>
        <!-- Button to download as HTML -->
        <button id="downloadHtmlBtn"
                class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105">
            Download HTML
        </button>
        <!-- Button to download as Markdown -->
        <button id="downloadMarkdownBtn"
                class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-3 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105">
            Download Markdown
        </button>
    </div>

    <script>
        // Get references to the DOM elements
        const richTextEditor = document.getElementById('richTextEditor');
        const xmlEditor = document.getElementById('xmlEditor');
        const aiPrompt = document.getElementById('aiPrompt');
        const generateBtn = document.getElementById('generateBtn');
        const toolbar = document.getElementById('toolbar');
        const downloadPdfBtn = document.getElementById('downloadPdfBtn');
        const downloadHtmlBtn = document.getElementById('downloadHtmlBtn');
        const downloadMarkdownBtn = document.getElementById('downloadMarkdownBtn');

        // Flag to prevent infinite loops during two-way binding
        let isUpdating = false;

        /**
         * Converts the HTML content from the rich text editor to DITA XML.
         * This is a simplified conversion for demonstration purposes.
         * A more robust solution would require a full DITA-OT-compliant parser.
         * @param {string} htmlString - The HTML content to convert.
         * @returns {string} The formatted DITA XML string.
         */
        function htmlToDita(htmlString) {
            if (!htmlString.trim()) {
                return '';
            }

            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const body = doc.body;

            let ditaXml = '<?xml version="1.0" encoding="UTF-8"?>\n' +
                          '<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">\n' +
                          '<topic id="my-topic">\n';

            const firstHeading = body.querySelector('h1, h2, h3');
            if (firstHeading) {
                ditaXml += `  <title>${firstHeading.textContent}</title>\n`;
                firstHeading.remove();
            } else {
                ditaXml += '  <title>New Topic</title>\n';
            }

            ditaXml += '  <body>\n';

            // Process all child nodes of the body
            body.childNodes.forEach(node => {
                if (node.nodeType === Node.ELEMENT_NODE) {
                    let xmlContent = '';
                    switch (node.tagName.toLowerCase()) {
                        case 'h1': // Convert h1 to a title, although it's removed above. This is for completeness.
                        case 'h2':
                        case 'h3':
                        case 'h4':
                        case 'h5':
                        case 'h6':
                            xmlContent = `    <section>${node.textContent}</section>\n`;
                            break;
                        case 'p':
                            let pContent = node.innerHTML;
                            pContent = pContent.replace(/<strong>(.*?)<\/strong>|<b>(.*?)<\/b>/g, '<bdo>$1$2</bdo>');
                            pContent = pContent.replace(/<em>(.*?)<\/em>|<i>(.*?)<\/i>/g, '<emphasis>$1$2</emphasis>');
                            pContent = pContent.replace(/<u>(.*?)<\/u>/g, '<ph style="text-decoration: underline;">$1</ph>');
                            xmlContent = `    <p>${pContent}</p>\n`;
                            break;
                        case 'ul':
                            xmlContent = `    <ul id="ul1">\n`;
                            node.querySelectorAll('li').forEach(li => {
                                xmlContent += `      <li>${li.textContent}</li>\n`;
                            });
                            xmlContent += `    </ul>\n`;
                            break;
                        case 'ol':
                            xmlContent = `    <ol id="ol1">\n`;
                            node.querySelectorAll('li').forEach(li => {
                                xmlContent += `      <li>${li.textContent}</li>\n`;
                            });
                            xmlContent += `    </ol>\n`;
                            break;
                        case 'blockquote':
                            xmlContent = `    <blockquote>${node.textContent}</blockquote>\n`;
                            break;
                        case 'a':
                            xmlContent = `    <xref href="${node.href}">${node.textContent}</xref>\n`;
                            break;
                        // Add more cases for other DITA elements as needed
                    }
                    ditaXml += xmlContent;
                }
            });

            ditaXml += '  </body>\n' +
                       '</topic>';
            return ditaXml;
        }

        /**
         * Converts DITA XML string back to a basic HTML representation.
         * This is a simplified process using DOMParser.
         * @param {string} ditaString - The DITA XML string to convert.
         * @returns {string} The formatted HTML string.
         */
        function ditaToHtml(ditaString) {
            if (!ditaString.trim()) {
                return '';
            }

            const parser = new DOMParser();
            let doc;
            try {
                doc = parser.parseFromString(ditaString, 'text/xml');
                const errorNode = doc.querySelector('parsererror');
                if (errorNode) {
                    console.error("XML Parsing Error:", errorNode.textContent);
                    return `<p class="text-red-500">Error parsing DITA XML. Please check your syntax.</p>`;
                }
            } catch (e) {
                console.error("XML Parsing Error:", e);
                return `<p class="text-red-500">Error parsing DITA XML: ${e.message}</p>`;
            }

            const topic = doc.querySelector('topic');
            if (!topic) {
                return '<p>No &lt;topic&gt; element found.</p>';
            }

            let htmlContent = '';

            const title = topic.querySelector('title');
            if (title) {
                htmlContent += `<h1>${title.textContent}</h1>`;
            }

            const body = topic.querySelector('body');
            if (body) {
                body.childNodes.forEach(node => {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        switch (node.tagName.toLowerCase()) {
                            case 'p':
                                let pContent = node.innerHTML;
                                pContent = pContent.replace(/<bdo>(.*?)<\/bdo>/g, '<strong>$1</strong>');
                                pContent = pContent.replace(/<emphasis>(.*?)<\/emphasis>/g, '<em>$1</em>');
                                pContent = pContent.replace(/<ph style="text-decoration: underline;">(.*?)<\/ph>/g, '<u>$1</u>');
                                htmlContent += `<p>${pContent}</p>`;
                                break;
                            case 'section':
                                htmlContent += `<h2>${node.textContent}</h2>`;
                                break;
                            case 'ul':
                                htmlContent += `<ul>${node.innerHTML}</ul>`;
                                break;
                            case 'ol':
                                htmlContent += `<ol>${node.innerHTML}</ol>`;
                                break;
                            case 'blockquote':
                                htmlContent += `<blockquote>${node.textContent}</blockquote>`;
                                break;
                            case 'xref':
                                htmlContent += `<a href="${node.getAttribute('href')}">${node.textContent}</a>`;
                                break;
                        }
                    }
                });
            }

            return htmlContent;
        }

        /**
         * Converts HTML to Markdown. This is a simple conversion for
         * demonstration and does not support all HTML tags.
         * @param {string} htmlString - The HTML content to convert.
         * @returns {string} The Markdown string.
         */
        function htmlToMarkdown(htmlString) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlString;

            let markdown = '';

            tempDiv.childNodes.forEach(node => {
                if (node.nodeType === Node.ELEMENT_NODE) {
                    let content = node.textContent;
                    let innerHTML = node.innerHTML;

                    switch (node.tagName.toLowerCase()) {
                        case 'h1':
                            markdown += `# ${content}\n\n`;
                            break;
                        case 'h2':
                            markdown += `## ${content}\n\n`;
                            break;
                        case 'h3':
                            markdown += `### ${content}\n\n`;
                            break;
                        case 'h4':
                        case 'h5':
                        case 'h6':
                        case 'p':
                            // Simple text formatting within paragraphs
                            innerHTML = innerHTML.replace(/<strong>(.*?)<\/strong>/g, '**$1**');
                            innerHTML = innerHTML.replace(/<em>(.*?)<\/em>/g, '*$1*');
                            innerHTML = innerHTML.replace(/<u>(.*?)<\/u>/g, '$1'); // Underline has no direct MD equivalent
                            markdown += `${innerHTML}\n\n`;
                            break;
                        case 'ul':
                            node.querySelectorAll('li').forEach(li => {
                                markdown += `* ${li.textContent}\n`;
                            });
                            markdown += '\n';
                            break;
                        case 'ol':
                            let i = 1;
                            node.querySelectorAll('li').forEach(li => {
                                markdown += `${i}. ${li.textContent}\n`;
                                i++;
                            });
                            markdown += '\n';
                            break;
                        case 'blockquote':
                            markdown += `> ${content}\n\n`;
                            break;
                        case 'a':
                            markdown += `[${node.textContent}](${node.getAttribute('href')})\n\n`;
                            break;
                    }
                }
            });

            return markdown;
        }
        
        // --- Gemini AI Integration ---
        generateBtn.addEventListener('click', async () => {
            const userPrompt = aiPrompt.value.trim();
            if (!userPrompt) {
                // Use a custom message box instead of alert()
                const message = 'Please enter a prompt before generating content.';
                richTextEditor.innerHTML = `<p class="text-red-500">${message}</p>`;
                return;
            }

            // Show loading state
            generateBtn.textContent = 'Generating...';
            generateBtn.disabled = true;
            generateBtn.classList.add('opacity-50', 'cursor-not-allowed');

            try {
                // Instruct the AI to respond in formatted HTML
                const chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: `Generate a response in HTML format. Do not include <!DOCTYPE> or <body> tags. The HTML should be a single block of content using h1, p, ul, ol, strong, and em tags. The prompt is: ${userPrompt}` }] });
                const payload = { contents: chatHistory };
                const apiKey = "AIzaSyDdj6VoNhgKHIh3myG_UPzfXseXRLPUldE" 
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;
                
                let response;
                let retryDelay = 1000;
                const maxRetries = 5;
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        if (response.ok) {
                           break;
                        }
                        if (response.status !== 429) {
                            throw new Error(`API Error: ${response.status} ${response.statusText}`);
                        }
                    } catch (error) {
                        if (i === maxRetries - 1) {
                           throw error;
                        }
                    }
                    if (i < maxRetries - 1) {
                        await new Promise(res => setTimeout(res, retryDelay));
                        retryDelay *= 2;
                    }
                }
                
                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                    const generatedHtml = result.candidates[0].content.parts[0].text;
                    
                    isUpdating = true;
                    // Directly insert the generated HTML
                    richTextEditor.innerHTML = generatedHtml;
                    const generatedDita = htmlToDita(generatedHtml);
                    xmlEditor.value = generatedDita;
                    isUpdating = false;

                } else {
                    console.error("API response did not contain content.");
                    richTextEditor.innerHTML = '<p class="text-red-500">Sorry, I couldn\'t generate content. Please try again.</p>';
                    xmlEditor.value = '';
                }

            } catch (error) {
                console.error('Error generating content:', error);
                richTextEditor.innerHTML = '<p class="text-red-500">There was an error connecting to the API. Please try again later.</p>';
                xmlEditor.value = '';
            } finally {
                // Reset loading state
                generateBtn.textContent = 'Generate';
                generateBtn.disabled = false;
                generateBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        });

        // Add Enter key functionality to the AI prompt textarea
        aiPrompt.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault(); // Prevent new line
                generateBtn.click();
            }
        });

        // --- Rich Text Editor Toolbar Logic ---
        toolbar.addEventListener('click', (event) => {
            const button = event.target.closest('button');
            if (button) {
                const command = button.dataset.command;
                const value = button.dataset.value;

                if (command === 'createLink') {
                    const url = prompt("Enter the URL for the link:");
                    if (url) {
                        document.execCommand(command, false, url);
                    }
                } else if (command === 'formatBlock') {
                    document.execCommand(command, false, `<${value}>`);
                } else {
                    document.execCommand(command, false, null);
                }
                
                // Ensure the content is updated after command execution
                const ditaXml = htmlToDita(richTextEditor.innerHTML);
                xmlEditor.value = ditaXml;
            }
        });

        // --- Event Listeners for Two-Way Sync ---

        // Listen for changes in the rich text editor to update the XML
        richTextEditor.addEventListener('input', () => {
            if (isUpdating) return;
            isUpdating = true;
            const ditaXml = htmlToDita(richTextEditor.innerHTML);
            xmlEditor.value = ditaXml;
            isUpdating = false;
        });

        // Listen for changes in the XML editor to update the rich text
        xmlEditor.addEventListener('input', () => {
            if (isUpdating) return;
            isUpdating = true;
            const htmlContent = ditaToHtml(xmlEditor.value);
            richTextEditor.innerHTML = htmlContent;
            isUpdating = false;
        });

        // --- Event Listeners for Download Buttons ---

        // Download HTML
        downloadHtmlBtn.addEventListener('click', () => {
            const content = richTextEditor.innerHTML;
            const blob = new Blob([content], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'document.html';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // Download PDF
        downloadPdfBtn.addEventListener('click', () => {
            const element = richTextEditor;
            // Use html2pdf.js to generate and download the PDF
            html2pdf().from(element).set({
                margin: 10,
                filename: 'document.pdf',
                html2canvas: { scale: 2 },
                jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
            }).save();
        });

        // Download Markdown
        downloadMarkdownBtn.addEventListener('click', () => {
            const markdownContent = htmlToMarkdown(richTextEditor.innerHTML);
            const blob = new Blob([markdownContent], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'document.md';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // Initial content sync on page load
        richTextEditor.innerHTML = ditaToHtml(xmlEditor.value);
    </script>
</body>
</html>
